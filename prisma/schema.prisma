// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // Use a direct, non-pooled connection for migrations; keep pooled URL for runtime
  directUrl = env("DIRECT_URL")
}

enum Role {
  ADMIN
  SUPERVISOR
  ATTENDANT
}

enum Platform {
  JUMIA
  KILIMALL
}

enum ShopRoleAtShop {
  ATTENDANT
  SUPERVISOR
}

enum ReturnStatus {
  REQUESTED
  IN_TRANSIT
  AT_HUB
  PICKED
  OVERDUE
}

enum PriceSource {
  MANUAL
  LEARNED
}

enum DiscrepancyType {
  ORDER_NOT_IN_PAYOUT
  AMOUNT_MISMATCH
  FEE_MISMATCH
  UNKNOWN
}

enum DiscrepancyStatus {
  OPEN
  RESOLVED
  IGNORED
}

enum OrderStatus {
  PENDING
  PROCESSING
  FULFILLED
  COMPLETED
  CANCELED
}

enum PaymentStatus {
  UNPAID
  PARTIAL
  PAID
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  image     String?
  role      Role     @default(ATTENDANT)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // many-to-many: what shops an attendant/supervisor manages
  managedShops Shop[] @relation("ManagedBy")

  // relations
  orders Order[]
  attendantCommissions AttendantCommission[]
  // ops back-relations
  commissionEarnings CommissionEarning[]
  returnsCreated ReturnCase[] @relation("ReturnCreatedBy")
  returnsApproved ReturnCase[] @relation("ReturnApprovedBy")
  returnPickups ReturnPickup[] @relation("PickupAssignee")
  evidenceTaken ReturnEvidence[] @relation("EvidenceTaker")
  actionLogs ActionLog[]
  
  // per-shop assignments
  userShops UserShop[]
  // Shop assignments (supervisor/attendant)
  assignments ShopAssignment[]
}

model Shop {
  id        String   @id @default(cuid())
  name      String
  location  String?
  phone     String?
  email     String?
  isActive  Boolean  @default(true)
  platform  Platform @default(JUMIA)
  credentialsEncrypted Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // manager assignments
  managers User[] @relation("ManagedBy")

  // Jumia API credentials for this shop (optional)
  apiConfig ShopApiConfig?
  // multiple credentials (optional)
  apiCredentials ApiCredential[]

  // fulfillment audit records
  fulfillmentAudits FulfillmentAudit[]

  // relations
  orders Order[]
  attendantCommissions AttendantCommission[]
  // ops back-relations
  costCatalogs CostCatalog[]
  settlementRows SettlementRow[]
  returnCases ReturnCase[]
  commissionRules CommissionRule[]
  
  // assignments and reconciliation/discrepancy back-relations
  userAssignments UserShop[]
  reconciliations Reconciliation[]
  discrepancies Discrepancy[]
  // shop assignments for supervisors/attendants
  assignments ShopAssignment[]
}

model JumiaAccount {
  id           String      @id @default(cuid())
  label        String
  clientId     String
  refreshToken String
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  shops        JumiaShop[]
}

model JumiaShop {
  id                      String       @id
  name                    String
  accountId               String
  lastOrdersUpdatedBefore DateTime?
  createdAt               DateTime     @default(now())
  updatedAt               DateTime     @updatedAt

  account                 JumiaAccount @relation(fields: [accountId], references: [id])
  orders                  JumiaOrder[]

  @@index([accountId])
}

model JumiaOrder {
  id                String    @id
  number            Int?
  status            String
  hasMultipleStatus Boolean?
  pendingSince      String?
  totalItems        Int?
  packedItems       Int?
  countryCode       String?
  isPrepayment      Boolean?
  createdAtJumia    DateTime?
  updatedAtJumia    DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  shopId            String
  shop              JumiaShop @relation(fields: [shopId], references: [id])

  @@index([shopId, status])
}

model ShopApiConfig {
  id        String   @id @default(cuid())
  shopId    String   @unique
  platform  String   @default("JUMIA")
  apiKey    String
  apiSecret String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  shop Shop @relation(fields: [shopId], references: [id])
}

model Product {
  id              String  @id @default(cuid())
  sku             String  @unique
  name            String
  category        String
  sellingPrice    Float
  lastBuyingPrice Float?
  minStockLevel   Int      @default(5)
  stockQuantity   Int      @default(0)
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  orders OrderItem[]
}

model Order {
  id            String   @id @default(cuid())
  orderNumber   String   @unique
  customerName  String
  shopId        String
  attendantId   String?
  status        OrderStatus @default(PENDING)
  totalAmount   Float
  paidAmount    Float      @default(0)
  paymentStatus PaymentStatus @default(UNPAID)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  shop      Shop     @relation(fields: [shopId], references: [id])
  attendant User?    @relation(fields: [attendantId], references: [id])
  items     OrderItem[]
  // ops back-relations
  settlementRows SettlementRow[]
  returnCases ReturnCase[]
}
model OrderItem {
  id           String  @id @default(cuid())
  orderId      String
  productId    String
  quantity     Int
  sellingPrice Float

  order   Order   @relation(fields: [orderId], references: [id])
  product Product @relation(fields: [productId], references: [id])
  // ops back-relations
  orderCosts OrderCost[]
  settlementRows SettlementRow[]
  profitSnapshots ProfitSnapshot[]
  commissionEarnings CommissionEarning[]
  returnAdjustments ReturnAdjustment[]
  returnCases ReturnCase[]
}

/// Commission configuration and snapshots
model CommissionPeriod {
  id        String   @id @default(cuid())
  name      String                    // e.g., "Aug 24 â†’ Sep 24"
  startDate DateTime
  endDate   DateTime
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  tiers CommissionTier[]
  attendantCommissions AttendantCommission[]
}

model CommissionTier {
  id         String   @id @default(cuid())
  periodId   String
  minSales   Float    // inclusive
  maxSales   Float    // inclusive
  payoutFlat Float    // flat KES payout for hitting a band

  period CommissionPeriod @relation(fields: [periodId], references: [id])
}

model AttendantCommission {
  id        String   @id @default(cuid())
  userId    String
  periodId  String
  shopId    String?     // null means aggregate across assigned shops
  sales     Float
  payout    Float
  computedAt DateTime   @default(now())

  user   User             @relation(fields: [userId], references: [id])
  period CommissionPeriod @relation(fields: [periodId], references: [id])
  shop   Shop?            @relation(fields: [shopId], references: [id])
}

// API credentials for external services (global or shop-scoped)
model ApiCredential {
  id        String   @id @default(cuid())
  scope     String   // "GLOBAL" or "SHOP:<shopId>"
  apiBase   String
  apiKey    String?
  apiSecret String?
  issuer    String?
  clientId  String?
  refreshToken String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // optional: limit which shop this applies to
  shopId String?
  shop   Shop? @relation(fields: [shopId], references: [id])
  @@unique([scope, shopId])
}

model Config {
  key   String  @id         // e.g., "commission_window", "admin_emails"
  json  Json
  updatedAt DateTime @updatedAt
}

// Minimal ingest table for Jumia orders
/// --- Ops extensions ---

model CostCatalog {
  id            String   @id @default(cuid())
  sku           String
  shopId        String?     // null = global cost
  cost          Decimal  @db.Decimal(12,2)
  effectiveFrom DateTime
  effectiveTo   DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  shop Shop? @relation(fields: [shopId], references: [id])

  @@index([sku, shopId, effectiveFrom])
}

model OrderCost {
  id          String   @id @default(cuid())
  orderItemId String
  unitCost    Decimal  @db.Decimal(12,2)
  costSource  String   // 'catalog' | 'override'
  createdAt   DateTime @default(now())

  orderItem OrderItem @relation(fields: [orderItemId], references: [id])
}

model SettlementRow {
  id          String   @id @default(cuid())
  shopId      String
  orderId     String?
  orderItemId String?
  kind        String   // 'item_price','commission','shipping_fee','refund','penalty',...
  amount      Decimal  @db.Decimal(12,2)
  ref         String?
  postedAt    DateTime
  raw         Json
  createdAt   DateTime @default(now())

  shop      Shop      @relation(fields: [shopId], references: [id])
  order     Order?    @relation(fields: [orderId], references: [id])
  orderItem OrderItem? @relation(fields: [orderItemId], references: [id])

  @@index([shopId, postedAt])
  @@index([orderId, orderItemId])
}

model ProfitSnapshot {
  id          String   @id @default(cuid())
  orderItemId String
  revenue     Decimal  @db.Decimal(12,2)
  fees        Decimal  @db.Decimal(12,2)
  shipping    Decimal  @db.Decimal(12,2)
  refunds     Decimal  @db.Decimal(12,2)
  unitCost    Decimal  @db.Decimal(12,2)
  qty         Int
  profit      Decimal  @db.Decimal(12,2)
  computedAt  DateTime @default(now())

  orderItem OrderItem @relation(fields: [orderItemId], references: [id])
}

model CommissionRule {
  id            String  @id @default(cuid())
  scope         String  // 'shop'|'sku'|'category'|'global'
  shopId        String?
  sku           String?
  category      String?
  type          String  // 'percent_profit'|'percent_gross'|'flat_per_item'
  rateDecimal   Decimal @db.Decimal(6,4)
  effectiveFrom DateTime
  effectiveTo   DateTime?
  createdBy     String
  createdAt     DateTime @default(now())

  shop Shop? @relation(fields: [shopId], references: [id])

  @@index([scope, shopId, sku, category, effectiveFrom])
}

model CommissionEarning {
  id          String   @id @default(cuid())
  staffId     String
  orderItemId String
  basis       String   // 'profit'|'gross'|'flat'
  qty         Int
  amount      Decimal  @db.Decimal(12,2)
  status      String   // 'pending'|'approved'|'reversed'
  calcDetail  Json
  createdAt   DateTime @default(now())

  staff     User      @relation(fields: [staffId], references: [id])
  orderItem OrderItem @relation(fields: [orderItemId], references: [id])
}

model ReturnCase {
  id          String   @id @default(cuid())
  shopId      String
  orderId     String
  orderItemId String?
  reasonCode  String
  // legacy `status` string is kept for compatibility; add `dueAt` and `pickedAt` for SLA tracking
  status      String   // 'requested'|'approved'|'pickup_scheduled'|'picked_up'|'received'|'resolved'|'rejected'
  dueAt       DateTime?
  pickedAt    DateTime?
  resolution  String?  // 'refund'|'replacement'|'repair'|'deny'
  createdBy   String
  approvedBy  String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  shop      Shop      @relation(fields: [shopId], references: [id])
  order     Order     @relation(fields: [orderId], references: [id])
  orderItem OrderItem? @relation(fields: [orderItemId], references: [id])
  creator   User      @relation("ReturnCreatedBy", fields: [createdBy], references: [id])
  approver  User?     @relation("ReturnApprovedBy", fields: [approvedBy], references: [id])
  pickups   ReturnPickup[]
  evidence  ReturnEvidence[]
  adjustments ReturnAdjustment[]

  @@index([shopId, status])
}

model ReturnPickup {
  id            String   @id @default(cuid())
  returnCaseId  String
  scheduledAt   DateTime
  carrier       String
  tracking      String?
  assignedTo    String   // staffId
  notes         String?
  createdAt     DateTime @default(now())

  returnCase ReturnCase @relation(fields: [returnCaseId], references: [id])
  assignee   User       @relation("PickupAssignee", fields: [assignedTo], references: [id])
}

model ReturnEvidence {
  id           String   @id @default(cuid())
  returnCaseId String
  type         String   // 'photo'|'video'|'signature'|'document'
  uri          String
  sha256       String
  takenBy      String
  takenAt      DateTime
  geo          Json?
  createdAt    DateTime @default(now())

  returnCase ReturnCase @relation(fields: [returnCaseId], references: [id])
  taker     User        @relation("EvidenceTaker", fields: [takenBy], references: [id])
}

model ReturnAdjustment {
  id             String   @id @default(cuid())
  returnCaseId   String
  orderItemId    String
  amount         Decimal  @db.Decimal(12,2)
  commissionImpact String // 'none'|'reverse'|'reduce'
  notes          String?
  createdAt      DateTime @default(now())

  returnCase ReturnCase @relation(fields: [returnCaseId], references: [id])
  orderItem  OrderItem  @relation(fields: [orderItemId], references: [id])
}

model ActionLog {
  id        String   @id @default(cuid())
  actorId   String
  entity    String   // e.g., 'ReturnCase','Order','CommissionRule'
  entityId  String
  action    String   // e.g., 'CREATE','UPDATE','APPROVE','STATE_CHANGE'
  before    Json?
  after     Json?
  createdAt DateTime @default(now())

  actor User @relation(fields: [actorId], references: [id])
  @@index([entity, entityId])
}

model UserShop {
  id         String         @id @default(cuid())
  userId     String
  shopId     String
  roleAtShop ShopRoleAtShop

  user       User           @relation(fields: [userId], references: [id])
  shop       Shop           @relation(fields: [shopId], references: [id])

  @@unique([userId, shopId])
}

/// Assignment model for supervisors/attendants per shop
model ShopAssignment {
  id        String   @id @default(cuid())
  userId    String
  shopId    String
  role      Role
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
  shop Shop @relation(fields: [shopId], references: [id])

  @@unique([userId, shopId, role])
}

model ProductCost {
  id        String      @id @default(cuid())
  productId String
  price     Decimal     @db.Decimal(12,2)
  source    PriceSource
  byUserId  String?
  createdAt DateTime    @default(now())

  @@index([productId])
}

model CommissionLedger {
  id              String   @id @default(cuid())
  userId          String
  periodStart     DateTime
  periodEnd       DateTime
  grossCommission Decimal  @db.Decimal(12,2) @default("0")
  penalties       Decimal  @db.Decimal(12,2) @default("0")
  netCommission   Decimal  @db.Decimal(12,2) @default("0")
  detail          Json?
  createdAt       DateTime @default(now())
}

model Reconciliation {
  id            String   @id @default(cuid())
  shopId        String
  day           DateTime
  ordersCount   Int
  payoutAmount  Decimal  @db.Decimal(12,2) @default("0")
  variance      Decimal  @db.Decimal(12,2) @default("0")
  notes         String?
  createdAt     DateTime @default(now())

  shop          Shop     @relation(fields: [shopId], references: [id])

  @@unique([shopId, day])
}

model Discrepancy {
  id        String           @id @default(cuid())
  shopId    String
  kind      DiscrepancyType
  ref       String
  amount    Decimal          @db.Decimal(12,2) @default("0")
  status    DiscrepancyStatus @default(OPEN)
  createdAt DateTime         @default(now())

  shop      Shop             @relation(fields: [shopId], references: [id])
}

model FulfillmentAudit {
  id             String   @id @default(cuid())
  idempotencyKey String   @unique
  shopId         String
  orderId        String
  status         Int
  action         String?
  ok             Boolean
  payload        Json
  s3Bucket       String?
  s3Key          String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  shop Shop @relation(fields: [shopId], references: [id])
  @@index([shopId, orderId])
}

/// Persisted catalog counters (per shop and aggregate "ALL")
model CatalogCounters {
  id           String   @id @default(cuid())
  // scope: 'SHOP' for per-shop entries, 'ALL' for aggregate across all shops
  scope        String
  shopId       String?

  // totals
  total        Int       @default(0)
  active       Int       @default(0)
  inactive     Int       @default(0)
  deleted      Int       @default(0)
  pending      Int       @default(0)
  visibleLive  Int       @default(0)
  // QC buckets
  qcApproved   Int       @default(0)
  qcPending    Int       @default(0)
  qcRejected   Int       @default(0)
  qcNotReady   Int       @default(0)
  // original granular maps (optional)
  byStatus     Json?
  byQcStatus   Json?
  approx       Boolean   @default(false)

  computedAt   DateTime  @default(now())
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // no explicit relation needed; shopId references Shop.id

  @@unique([scope, shopId])
  @@index([scope, shopId, computedAt])
}


